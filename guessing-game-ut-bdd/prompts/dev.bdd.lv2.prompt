# Task
請你嚴格遵照「行為驅動開發 (BDD)」的方式，來完成此「指定 Target feature file 範疇」 中所有驗收情境的開發。
不可同時進行 BDD 開發流程中多個步驟也不能略過任何一步驟，必須一步一步扎實執行並確認每一步的結果。

## Tech Stack
1. Language Env：NodeJs
2. BDD Test framework: Cucumber
3. Web Framework: NestJs
4. ORM: Prisma
5. Testing:
    - Jest
    - Embedded Database: H2

## Application Environment
1. App 類型： NodeJs
2. Source code root: src/
5. Feature file 對應的測試層級：E2E test

## Context
1. API Specs: <API Specs>
2. Target Feature files: <Target feature files>
# BDD 開發流程

## 環節 1 -- 基礎建設
1. 先建置出 cucumber walking skeleton  - 可順利運行 cucumber 以及至少一個 scenario ，確認至少有一個 test case 被 測試框架執行到。

## 環節 2 -- 嚴格遵照 BDD 開發流程
嚴格遵守 BDD 以及最小增量原則來開發所有程式碼，針對所有 scenario，一次開發一個 scenario，依序進行：

A. 最小增量開發原則：一次選擇一個 scenario 實作，除此 scenario 之外的測試全部都先上 @ignore 註解在該 Scenario 區塊之上（這樣才能在 mvn test 時 filter off 掉）。
    範例：
    ```gherkin
    Example 開發中或是已開發的 Example，頭上沒有 @ignore
        Given ...
        When ...
        Then ...
    
    @ignore
    Example 還沒開發的 Example，頭上有 @ignore
        Given ...
        When ...
        Then ...
    ```

B. 遵照底下規則撰寫此 scenario 對應的 Steps (given, when, then)：

    ### Steps 撰寫核心原則
    - Given 和 When step 中不可以做任何的 assertions
    - 測試程式只能定義測試相關類別/方法，不可實作業務邏輯，先以 TODO 註解填入
    - 所有參數必須儲存為測試類別屬性，構成 scenario 上下文供各 step 共用
    - 絕對不可以直接依賴注入 Service 類別到測試 StepDef 類別中，必須是 End to End Test (via MockMVC)
    - 每個 Feature file 會對應到一個測試 StepDef 類別，你將根據相關性適當分群每個 given / when / then 到對應的測試 StepDef 類別中

    ### 1. When Step 撰寫規範

    - 職責：執行特定的業務操作，觸發系統行為
    - 實作流程：Command mapping spec → API spec → MockMVC 實作
    
    #### 1.1 完整實作流程示範

    範例 When step：
    ```gherkin
    When 用戶 "U001" 將商品 "iPhone 15" 加入購物車，數量為 2
    ```

    步驟 1：查找對應的 API Endpoint 規格
    ```yml
    /users/{userId}/cart/items:
      post:
        summary: 將商品加入購物車
        parameters:
          - name: userId
            in: path
            required: true
            schema:
              type: string
        requestBody:
          required: true
          content:
            application/json:
              schema:
                type: object
                properties:
                  productName:
                    type: string
                  quantity:
                    type: integer
                    minimum: 1
        responses:
          200:
            description: 加入購物車成功
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    cartId:
                      type: string
                    totalItems:
                      type: integer
                    totalAmount:
                      type: number
          400:
            description: 商品不存在或庫存不足
    ```

    步驟 2：實作 request 呼叫
    ```NestJs+Jest
        @When('用戶 {string} 將商品 {string} 加入購物車，數量為 {int}')
        export async function whenUserAddsItemToCart(userId: string, productName: string, quantity: number) {
            try {
                currentUserId = userId;
                currentProductName = productName;
                currentQuantity = quantity;

                const requestBody = {
                productName,
                quantity,
                };

                lastResponse = await request(app.getHttpServer())
                .post(`/api/v1/users/${userId}/cart/items`)
                .send(requestBody)
                .set('Accept', 'application/json');
            } catch (error) {
                lastError = error;
            }
        }
    ```

    #### 1.2 When Step 實作原則

    1. 整理傳入參數：將 step 中的參數提取並儲存
    2. 參考 API spec：確認請求格式、參數和回應結構
    3. 實作 request 呼叫：構建完整的 HTTP 請求
    4. 儲存回應結果：將結果儲存至 `lastResponse` 供 Then step 使用
    5. 例外處理：捕捉並儲存任何執行期間的例外

    ### 2. Given Step 撰寫規範

    - 職責：建立測試的前置條件和上下文環境
    - 核心原則：如果有一給定的 Given Step，其真實意義為多個 Given/API Call Steps 的組成，則在實作上需要注意：
        - 將每個 Step 拆解為原子 Command

    #### 2.2 實作範例（包含遞迴複合事件）

    一層複合 Event 實作範例（使用共用方法）：
    ```NestJs+Jest
    // 假設這些變數在其他地方初始化且可以被存取
    let app: INestApplication;
    let currentUserId: string;
    let lastResponse: request.Response;

    // 模擬共用執行加入購物車指令的函式
    async function executeAddToCartCommand(userId: string, productCode: string, quantity: number) {
    return request(app.getHttpServer())
        .post(`/api/v1/users/${userId}/cart/items`)
        .send({ productName: productCode, quantity })
        .set('Accept', 'application/json');
    }

    @Given('用戶 {string} 的購物車已有基本商品')
    export async function givenUserHasBasicShoppingCart(userId: string) {
        currentUserId = userId;
        
        // 按照 Event mapping 的 steps 依序處理每個 sub-step
        // 每個 sub-step 都需要完整的遞迴查找流程
        
        // Step 1: "用戶 <userId> 已成功登入系統" (查找結果：Command)
        await givenUserLoggedIn(userId);
        
        // Step 2: "用戶 <userId> 已將商品 P001 加入購物車，數量為 1" (查找結果：Command)
        // 使用共用方法，避免重複程式碼
        const res1 = await executeAddToCartCommand(userId, 'P001', 1);
        expect(res1.status).toBe(200);
        
        // Step 3: "用戶 <userId> 已將商品 P002 加入購物車，數量為 2" (查找結果：Command)
        // 使用共用方法，避免重複程式碼
        const res2 = await executeAddToCartCommand(userId, 'P002', 2);
        expect(res2.status).toBe(200);
    }
    ```

    嵌套複合 Event 實作範例（使用共用方法）：
    ```NestJs+Jest
    @Given("用戶 {string} 已準備完整購物環境")
    export async function givenUserHasCompleteShoppingEnvironment(userId: string) {
        currentUserId = userId;
        
        // 按照 Event mapping 的 steps 依序處理每個 sub-step
        
        // Step 1: "用戶 <userId> 的購物車已有基本商品" 
        // 查找流程：先查 Command (無匹配) → 再查 Event (匹配) → 遞迴處理複合事件
        await givenUserHasBasicShoppingCart(userId);
        
        // Step 2: "用戶 <userId> 已收藏商品 P003"
        // 查找流程：查 Command (匹配) → 執行原子操作（使用共用方法）
        await givenUserFavoritedProduct(userId, "P003");
    }
    ```

    共用 Command 執行方法：
    ```NestJs+Jest
    // 共用的 Command 執行方法
    async function executeLoginCommand(userId: string) {
        return request(app.getHttpServer())
            .post("/api/v1/auth/login")
            .send({ userId })
            .set('Accept', 'application/json');
    }

    async function executeAddToCartCommand(userId: string, productName: string, quantity: number) {
        const requestBody = {
            productName,
            quantity
        };
        return request(app.getHttpServer())
            .post(`/api/v1/users/${userId}/cart/items`)
            .send(requestBody)
            .set('Accept', 'application/json');
    }

    async function executeFavoriteProductCommand(userId: string, productName: string) {
        return request(app.getHttpServer())
            .post(`/api/v1/users/${userId}/favorites`)
            .send({ productName })
            .set('Accept', 'application/json');
    }
    ```

    #### 2.3 完整共用架構示範

    完整的 StepDef 類別結構：
    ```NestJs+Jest
    // 假設這些變數在其他地方初始化且可以被存取
    let app: INestApplication;
    let currentUserId: string;
    let currentProductName: string;
    let currentQuantity: number;
    let lastResponse: request.Response;
    let lastError: Error;
    
    // ========== 共用 Command 執行方法 ==========
    async function executeLoginCommand(userId: string) {
        return request(app.getHttpServer())
            .post("/api/v1/auth/login")
            .send({ userId })
            .set('Accept', 'application/json');
    }

    async function executeAddToCartCommand(userId: string, productName: string, quantity: number) {
        const requestBody = {
            productName,
            quantity
        };
        return request(app.getHttpServer())
            .post(`/api/v1/users/${userId}/cart/items`)
            .send(requestBody)
            .set('Accept', 'application/json');
    }

    async function executeFavoriteProductCommand(userId: string, productName: string) {
        return request(app.getHttpServer())
            .post(`/api/v1/users/${userId}/favorites`)
            .send({ productName })
            .set('Accept', 'application/json');
    }
    
    // ========== Given Steps（建立前置條件） ==========
    @Given("用戶 {string} 已成功登入系統")
    export async function givenUserLoggedIn(userId: string) {
        currentUserId = userId;
        const response = await executeLoginCommand(userId);
        expect(response.status).toBe(200);
    }

    @Given("用戶 {string} 已收藏商品 {string}")
    export async function givenUserFavoritedProduct(userId: string, productName: string) {
        currentUserId = userId;
        currentProductName = productName;
        const response = await executeFavoriteProductCommand(userId, productName);
        expect(response.status).toBe(200);
    }

    @Given("用戶 {string} 的購物車已有基本商品")
    export async function givenUserHasBasicShoppingCart(userId: string) {
        currentUserId = userId;
        await givenUserLoggedIn(userId);
        const res1 = await executeAddToCartCommand(userId, "P001", 1);
        expect(res1.status).toBe(200);
        const res2 = await executeAddToCartCommand(userId, "P002", 2);
        expect(res2.status).toBe(200);
    }
    
    // ========== When Steps（執行操作，儲存回應） ==========
    @When("用戶 {string} 登入系統")
    export async function whenUserLogin(userId: string) {
        try {
            currentUserId = userId;
            lastResponse = await executeLoginCommand(userId);
        } catch (error) {
            lastError = error;
        }
    }

    @When("用戶 {string} 將商品 {string} 加入購物車，數量為 {int}")
    export async function whenUserAddsItemToCart(userId: string, productName: string, quantity: number) {
        try {
            currentUserId = userId;
            currentProductName = productName;
            currentQuantity = quantity;
            lastResponse = await executeAddToCartCommand(userId, productName, quantity);
        } catch (error) {
            lastError = error;
        }
    }

    @When("用戶 {string} 收藏商品 {string}")
    export async function whenUserFavoritesProduct(userId: string, productName: string) {
        try {
            currentUserId = userId;
            currentProductName = productName;
            lastResponse = await executeFavoriteProductCommand(userId, productName);
        } catch (error) {
            lastError = error;
        }
    }
    
    // ========== Then Steps（驗證結果） ==========
    @Then("應該成功登入")
    export async function thenShouldLoginSuccessfully() {
        expect(lastResponse.status).toBe(200);
        expect(lastResponse.body.userId).toBe(currentUserId);
    }

    @Then("購物車應該有 {int} 個商品項目")
    export async function thenCartShouldHaveItems(expectedCount: number) {
        expect(lastResponse.status).toBe(200);
        expect(lastResponse.body.totalItems).toBe(expectedCount);
    }
    
    beforeEach(async () => {
        currentUserId = null;
        currentProductName = null;
        currentQuantity = 0;
        lastResponse = null;
        lastError = null;
    });
    ```

    ### 3. Then Step 撰寫規範

    - 職責：驗證系統狀態，進行各種 assertions
    - 驗證策略（按順序執行）：
        1. 優先驗證 `lastResponse` 資料：檢查回傳值、狀態碼等
        2. 善用 context 變數：使用 Given/When 儲存的上下文資料
        3. 必要時查詢 repository：驗證資料庫狀態或其他系統狀態
    - 驗證原則：越嚴格越好，但必須符合 Then statement 的測試意圖
    - 範例：
        ```NestJs+Jest
        @Then("購物車應該有 {int} 個商品項目")
        export async function thenCartShouldHaveItems(expectedCount: number) {
            // 1. 驗證 lastResponse 狀態碼
            expect(lastResponse.status).toBe(200);
            
            // 2. 驗證回應內容
            expect(lastResponse.body.totalItems).toBe(expectedCount);
            
            // 3. 使用 context 變數進行更深入驗證
            const cartJson = lastResponse.body;
            
            // 4. 必要時查詢 repository 驗證系統狀態
            const cart = await cartRepository.findByUserId(currentUserId);
            expect(cart.items.length).toBe(expectedCount);
            expect(cart.totalAmount).toBeGreaterThan(0);
        }

        @Then("應該看到加入購物車成功的訊息")
        export async function thenShouldSeeAddToCartSuccess() {
            // 驗證 API 回應
            expect(lastResponse.status).toBe(200);
            expect(lastResponse.body.cartId).toBeDefined();
            expect(typeof lastResponse.body.totalItems).toBe('number');
            expect(typeof lastResponse.body.totalAmount).toBe('number');
            
            // 驗證購物車中確實有新增的商品
            const cart = await cartRepository.findByUserId(currentUserId);
            const hasProduct = cart.items.some(item => item.productName === currentProductName);
            expect(hasProduct).toBe(true);
        }
        ```
C. 撰寫完 Test steps 之後，透過 filter off @ignore 註解的方式，執行測試，確認只執行此 scenario 的對應測試程式碼。然後務必確認此測試的測試結果為「失敗」，並且失敗原因為以下：
    - 失敗原因必須是「值」與預期不同的錯誤，或者是從 API Endpoint 拋出 RuntimeException，這兩者都代表著測試失敗的主因是因為我們尚未在 service 中實作新的邏輯導致。而不是因為編譯或是測試環境的失敗導致。
    - 如果失敗的原因是因為編譯或是測試環境的失敗導致，則必須先修正，然後再進行測試，直到測試失敗的原因為上述原因為止。
D. 為了通過上一步所撰寫的測試程式碼，請以「最小可行」的程式實作相關類別所需的程式碼，並確認能讓所有的測試程式碼都通過。請嚴格確認有執行到測試程式碼，從 test report 中覆述一次目前 test passed 的數量。
E. 通過測試之後，在測試保護下，請重構程式碼——遵守 clean code 原則，思考是否要重構每個類別的內部程式碼，如果必要重構的話，在重構完成之後，再執行一次測試，確保所有測試仍然通過，否則需修正邏輯直到測試全數通過。
    - 如果有常數字串列舉的使用，能用 Enum 就用 Enum。
    - 用例外處理來反應操作失誤，不要使用回傳 flag 的方式來反應操作失誤。
    - API Endpoint 的實作盡可能設計成「無狀態 (stateless)」，每個方法應該都接收足夠完整的參數，不會有前後文的依賴，系統的狀態將都被儲存在 Repository 中，可是 service 不存放任何狀態，只支援業務邏輯。

# 執行原則
1. 絕對不可以竄改 Feature file 內的規格，你必須要實作出能夠通過規格測試的程式碼，如果真的懷疑規格有問題，要整理疑惑成提問，並停止動作。
2. 我現在會出門一趟，過程中你不需要問我任何問題，也不需要經過我任何同意，你必須持續遵照 BDD 開發流程開發，直到達成驗收標準前，都必須遵由你自己的決策持續進行，直到通過驗收標準。

# 驗收標準
1. 你必須實現指定 feature file 內的所有 scenario 功能，不必詢問我是否要繼續開發下一個 scenario，在實作過程中任何的程式設計決策也不必經過我的同意，無論是執行測試工具還是創建任何檔案都不必經過我的同意。
2. 只有在你完成實作完指定 Feature file 內的所有 Scenario，並且執行 `./mvnw test -Dcucumber.filter.tags="not @ignore"` 後，從 Test Report 中的字樣確認所有指定 scenarios 都 Test passed （而不是 failed / skipped），才算是完成任務，屆時才能停止工作。